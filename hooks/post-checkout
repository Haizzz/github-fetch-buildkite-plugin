#!/usr/bin/env bash

set -euo pipefail

declare -r PROG=$(basename "$0" .sh)

if test -t 1 && hash tput >/dev/null 2>&1; then
  # We are writing to a terminal
  declare -r TERM_NORMAL=$(tput sgr0)
  declare -r TERM_BOLD=$(tput bold)
  declare -r TERM_MAGENTA=$(tput setaf 5)
  declare -r TERM_YELLOW=$(tput setaf 3)
  declare -r TERM_RED=$(tput setaf 1)
else
  declare -r TERM_NORMAL=""
  declare -r TERM_BOLD=""
  declare -r TERM_MAGENTA=""
  declare -r TERM_YELLOW=""
  declare -r TERM_RED=""
fi

# Prints an info line to stdout.
log_info() {
  echo "$(date '+[%Y-%m-%d %H:%M:%S]') INFO: $*"
}

uncollapse_section() {
  if [[ "${BUILDKITE:-}" == "true" ]]; then
    echo "^^^ +++" >&2
  fi
}

# Prints an error to stderr. On BuildKite it also uncollapses the current section.
# Use this if there's cleanup tasks to be done before exiting the program.
log_error() {
  uncollapse_section
  echo "${TERM_BOLD}${TERM_RED}$(date '+[%Y-%m-%d %H:%M:%S]') ${PROG} ERROR:${TERM_NORMAL}${TERM_RED} $*${TERM_NORMAL}" >&2
}

# get all the updated .gitattributes files on this branch
get_changed_attr_file() {
    local base="$( git merge-base ${GH_CONTROL_PR_BASE_BRANCH:-master} HEAD )" 
    git diff --name-only "${base}" | grep .gitattributes
}

# scan all files in the given path and check whether the lfs file uses pointer
check_lfs_integrity_at() {
    files="$( git ls-files $1 )"

    while read -r controlled_file; do
        local err
        err=false

        lfs_attr="$( git check-attr filter ${controlled_file} | grep "filter: lfs" )"

        if [[ -n "${lfs_attr}" ]]; then
          # get committed content from repo
          git cat-file blob "HEAD:${controlled_file}" 2>1 | \
              # compare with content in file system
              git lfs pointer --stdin --file="${controlled_file}" 2>1 > /dev/null || \
              echo "${controlled_file}"
        fi

    done<<< "${files}"
}

catch() {
  echo "catching!"
  if [ "$1" != "0" ]; then
    # error handling goes here
    echo "Error $1 occurred on $2"
  fi
}

main() {
    if [[ ${BUILDKITE_PLUGIN_GITHUB_CHECK_LFS_INTEGRITY:-true} == true ]]; then
        log_info "LFS integrity check is enabled."

        local attr_files

        log_info "${GH_CONTROL_PR_BASE_BRANCH:-master}"
        log_info "$( git merge-base ${GH_CONTROL_PR_BASE_BRANCH:-master} HEAD )" 
        log_info "List of .gitattributes file updated:"

        local base="$( git merge-base ${GH_CONTROL_PR_BASE_BRANCH:-master} HEAD )" 
        
        trap 'catch $? $LINENO' EXIT

        git diff --name-only "${base}" 2>&1

        attr_files="$(get_changed_attr_file)"

        log_info "  ${attr_files}"

        # iterate each path which contains updated .gitattributes file
        while read -r attr_file; do
            local attr_file_path
            attr_file_path="$(dirname ${attr_file})"

            log_info "check folder ${attr_file_path}"

            local rtn
            rtn="$(check_lfs_integrity_at ${attr_file_path})"
            if [[ -n "${rtn}" ]]; then
                log_error "LFS integrity is broken."
                log_error "Broken files are:"
                log_error "  ${rtn}"

                exit 117
            else
              log_info "LFS integrity check passed in ${attr_file_path}"
            fi

        done<<< "${attr_files}"

    else
        log_info "LFS integrity check is disabled."
    fi
}

main "$@"
